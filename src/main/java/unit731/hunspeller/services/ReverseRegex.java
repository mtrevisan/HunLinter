package unit731.hunspeller.services;

import dk.brics.automaton.Automaton;
import dk.brics.automaton.RegExp;
import dk.brics.automaton.State;
import dk.brics.automaton.Transition;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Random;


/**
 * An object that will generate text from a regular expression. In a way, it's the opposite of a regular expression
 * matcher: an instance of this class will produce text that is guaranteed to match the regular expression passed in.
 */
public class ReverseRegex{

	private final Automaton automaton;


	/**
	 * Constructs a new instance, accepting the regular expression and the randomizer.
	 *
	 * @param regex The regular expression. (Not <code>null</code>.)
	 * @throws IllegalArgumentException If the regular expression is invalid.
	 */
	public ReverseRegex(String regex){
		Objects.requireNonNull(regex);

		RegExp re = new RegExp(regex);
		automaton = re.toAutomaton();
	}

	/**
	 * Generates all the strings that are guaranteed to match the regular expression passed to the constructor.
	 */
//	public List<String> generate(){
//		StringBuilder sb = new StringBuilder();
//		generate(sb, automaton.getInitialState());
//		return sb.toString();
//	}

	/**
	 * Generates a string that is guaranteed to match the regular expression passed to the constructor.
	 * 
	 * @param random	The random generator
	 * @return	One of the possible texts generated by the regex
	 */
	public String generateRandom(Random random){
		return generate(automaton.getInitialState(), random);
	}

	private List<String> generate(State state){
		List<String> words = new ArrayList<>();
		StringBuilder sb = new StringBuilder();
		while(true){
			List<Transition> transitions = state.getSortedTransitions(false);
			if(transitions.isEmpty())
				break;

			int length = sb.length();
			int optionCount = transitions.size() - (state.isAccept()? 0: 1);
			for(int option = 1; option <= optionCount; option ++){
				//0 is considered as a stop
				if(state.isAccept() && option == 0){
					words.add(sb.toString());

					sb.setLength(length);

					break;
				}

				//moving on to next transition
				Transition transition = transitions.get(option - (state.isAccept()? 1: 0));
				char chr = (char)getRandomInt(random, transition.getMin(), transition.getMax());
				sb.append(chr);

				state = transition.getDest();
			}
		}
		return words;
	}

	private String generate(State state, Random random){
		StringBuilder sb = new StringBuilder();
		while(true){
			List<Transition> transitions = state.getSortedTransitions(false);
			if(transitions.isEmpty())
				break;

			int optionCount = transitions.size() - (state.isAccept()? 0: 1);
			int option = getRandomInt(random, 0, optionCount);
			//0 is considered as a stop
			if(state.isAccept() && option == 0)
				break;

			//moving on to next transition
			Transition transition = transitions.get(option - (state.isAccept()? 1: 0));
			char chr = (char)getRandomInt(random, transition.getMin(), transition.getMax());
			sb.append(chr);

			state = transition.getDest();
		}
		return sb.toString();
	}

	/**
	 * Generates a random number within the given bounds.
	 *
	 * @param min	The minimum number (inclusive).
	 * @param max	The maximum number (inclusive).
	 * @param random	The object used as the randomizer.
	 * @return	A random number in the given range.
	 */
	private static int getRandomInt(Random random, int min, int max){
		//use random.nextInt as it guarantees a uniform distribution
		return random.nextInt(max - min + 1) + min;
	}

}
