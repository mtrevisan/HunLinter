package unit731.hunspeller.services;

import dk.brics.automaton.Automaton;
import dk.brics.automaton.RegExp;
import dk.brics.automaton.State;
import dk.brics.automaton.Transition;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Random;
import java.util.function.BiFunction;
import java.util.function.Function;


/**
 * An object that will generate text from a regular expression. In a way, it's the opposite of a regular expression
 * matcher: an instance of this class will produce text that is guaranteed to match the regular expression passed in.
 */
public class ReverseRegex{

	private final Automaton automaton;


	/**
	 * Constructs a new instance, accepting the regular expression and the randomizer.
	 *
	 * @param regex The regular expression. (Not <code>null</code>.)
	 * @throws IllegalArgumentException If the regular expression is invalid.
	 */
	public ReverseRegex(String regex){
		Objects.requireNonNull(regex);

		RegExp re = new RegExp(regex);
		automaton = re.toAutomaton();
	}

	/**
	 * Generates all the strings that are guaranteed to match the regular expression passed to the constructor.
	 * 
	 * @param limit	Limited number of '*'
	 * @return	The list of all the possible texts generated by the regex, limited by {@code limit}
	 */
//	public List<String> generate(int limit){
//		return generate(automaton.getInitialState(), limit);
//	}

	/**
	 * Generates a string that is guaranteed to match the regular expression passed to the constructor.
	 * 
	 * @param random	The random generator
	 * @return	One of the possible texts generated by the regex
	 */
	public String generateRandom(Random random){
		return generate(automaton.getInitialState(), random);
	}

//	private List<String> generate(State state, int limit){
//		List<String> words = new ArrayList<>();
//		while(true){
//			StringBuilder sb = new StringBuilder();
//			while(true){
//				List<Transition> transitions = state.getSortedTransitions(false);
//				if(transitions.isEmpty())
//					break;
//
//				int optionCount = transitions.size() - (state.isAccept()? 0: 1);
//				for(int option = 1; option < optionCount; option ++){
//					//moving on to next transition
//					Transition transition = transitions.get(option - (state.isAccept()? 1: 0));
//					char chr = fnCharIntoTransition.apply(transition.getMin(), transition.getMax());
//					sb.append(chr);
//
//					state = transition.getDest();
//				}
//				if(state.isAccept())
//					break;
//			}
//
//			words.add(sb.toString());
//		}
//		return words;
//	}

	private String generate(State state, Random random){
		Function<Integer, Integer> fnTransition = (max) -> getRandomInt(random, 0, max);
		BiFunction<Character, Character, Character> fnCharIntoTransition = (min, max) -> (char)getRandomInt(random, min, max);
		return generate(state, fnTransition, fnCharIntoTransition);
	}

	private String generate(State state, Function<Integer, Integer> fnTransition, BiFunction<Character, Character, Character> fnCharIntoTransition){
		StringBuilder sb = new StringBuilder();
		while(true){
			List<Transition> transitions = state.getSortedTransitions(false);
			if(transitions.isEmpty())
				break;

			int optionCount = transitions.size() - (state.isAccept()? 0: 1);
			int option = fnTransition.apply(optionCount);
			//0 is considered as a stop
			if(state.isAccept() && option == 0)
				break;

			//moving on to next transition
			Transition transition = transitions.get(option - (state.isAccept()? 1: 0));
			char chr = fnCharIntoTransition.apply(transition.getMin(), transition.getMax());
			sb.append(chr);

			state = transition.getDest();
		}
		return sb.toString();
	}

	/**
	 * Generates a random number within the given bounds.
	 *
	 * @param min	The minimum number (inclusive).
	 * @param max	The maximum number (inclusive).
	 * @param random	The object used as the randomizer.
	 * @return	A random number in the given range.
	 */
	private static int getRandomInt(Random random, int min, int max){
		//use random.nextInt as it guarantees a uniform distribution
		return random.nextInt(max - min + 1) + min;
	}

}
